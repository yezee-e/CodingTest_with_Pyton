# 그리디 알고리즘
***
* **현재 상황에서 지금 당장 좋은 것만 고르는 방법**을 의미   
* 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구    
* 그리디해법은 그 정당성 분석이 중요    
  단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
* 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많음 -> BUT, 코딩테스트에서 대부분의 그리디 문제는 **탐욕법으로 얻은 해가 최적의 해가 되는 상황에서 이론을 추론**할 수 있어야 풀리도록 출제

### 🚀<문제> 거스름돈   
***
**:문제설명**    
당신은 음식점의 계산을 도와주는 점원    
카눙ㄴ터에는 거스름돈으로 사용할 500원,100원,50원,10원짜리 동전이 무한히 존재한다고 가정. 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하시오.(단, 거슬러 줘야할 돈 N은 항상 10의 배수) 

**:문제해결아이디어**    
최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러 준다    
N원을 거슬러 줘야할때 , 가장 먼저 500원으로 거슬러 줄 수 있는 만큼 거슬러 준다     
이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 잇는 만큼 거슬러준다    
N=1,260일때의 예시를 확인

**:정당성 분석**    
가장 큰 화폐단위부터 돈을 거슬러주는 것이 최적의 해를 보장하는 이유는 무엇일까?      
가지고 있는 동전 중에서 **큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문**    
만약에 800원을 거슬러줘야하는대 화폐단위가 500원,400원,100원이라면 어떻게 될까? 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토해야함

```py
#거스름돈:답안 예시
n=1260
count=0

#큰 단위의 화폐부터 차례대로 확인
array =[500,100,50,10]

for coin in array:
  count +=//coin #해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
  n %=coin
print(count)

# 화폐의 종류가 k라고 할때, 소스코드의 시간복잡도는 0(k)
# 알고리즘의 시간복잡도는 거슬러줘야하는 금액과는 무관하며, 동전의 총 종류에만 영향은 받음
```

### 🚀<문제> 1이 될 때까지
***
**:문제설명**   
어떠한 수 n이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행(단, 두번째 연산은 n이 k로 나누어 떨어질 때만 선택)   
1. n에서 1을 뺍니다
2. n을 k로 나눕니다
 
예를 들어 n이 17, k가 4라고 가정   
이때 1번의 과정을 수행하면 n은 16이 된다
이후에 2번의 과정을 수행하면 n은 1   
결과적으로 이 경우 전체 과정을 실행한 횟수는 3(이는 n을 1로 만드는 최소 횟수)   
n과 k가 주어질때 n이 1이 될때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수를 구하는 프로그램을 작성 

**:문제조건**

<img src="pic\1이될때까지_문제조건.png" width=80% height="20%"></img>

**:정당성 분석**
가능하면 최대한 많이 나누는 작업이 최적의 해를 항상 보장할 수 있을까?   
k가 2이상이기만 하면, k로 나누는 것이 1을빼는 것 보다 항상 빠르게 n을 줄일 수 있다    
또한 n은 항상 1에 도달(최적의 해 성립)

```py

# n,k을 공백을 기준으로 구분하여 입력 받기
n,k =map(int,input(),split())

result=0

while True:
#n이 k로 나누어 떨어지는 수가 될때까지 빼기
    target =(n//k)*k  #n을 k로 나눈 몫에다가 k를 곱한 값을넣어줌으로서 k로 나누어떨어지는 수 찾기
    result +=(n-target) #n-target은 1을 빼는 연산을 몇번할지 한번에 계산
    n=target

    #n이 k보다 작을때 (더 이상 나눌 수 없을때 )반복문 탈출
    if n<k:
        break
    #k로 나누기
    result +=1
    n//=k

#마지막으로 남은 수에 대하여 1씩 빼기
result +=(n-1)
print(result)
```


### 🚀<문제> 곱하기 혹은 더하기
***
**:문제설명**   
각 자리가 숫자(0부터9)로만 이루어진 문자열 s가 주어졌을때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x'혹은 '+'연산자를 넣어 결과적으로 **만들어질 수 있는 가장 큰 수를 구하는 프로그램**을 작성    
단, '+'보다 'x'를 먼저 계산하는 일반적인 방식과는 달리, **모든 연산은 왼쪽부터 순서대로** 이루어진다고 가정    
또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력   

**:문제해결아이디어**   
대부분의 경우 '+'보다는 'x'가 더 값을 크게 만듬    
다만 두 수 중에서 하나라도 '0'혹은 '1'인 경우 곱하기 보다 더하기 수행이 효율적   
즉, 두 수에 대하여 연산을 수행할때, 두 수 중에서 하나라도 1이하인 경우에는 더하고, 두 수가 모든 2이상인 경우에느느 곱하면 정답

**:답안예시**    
```py
data=input()

#첫번째 문자를 숫자로 변경하여 대입
result =int(data[0])

for i in range(1, len(data)):
    # 두 수 중에서 하나라도 '0'혹은 '1'인 경우, 곱하기보다는 더하기 수행
    num =int(data[i])
    if num <=1 or result <=1:
        result +=num
    else:
        result *=num
print(result)
```





