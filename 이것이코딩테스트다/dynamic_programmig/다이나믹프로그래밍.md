# 다이나믹 프로그래밍(동적계획법)
* 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
* 이미 계산된결과(작은문제)는 별도의 메모리 영역에 다시 저장하여 다시 계산되지 않도록함
* 구현은 일반적으로 두가지방식(탑다운과 보텀업)으로 구성
* 일반적인 프로그래밍 분양에서 동적의 의미?
    * 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법
    * 반면에 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미없이 사용된 단어

* 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있다
    1. 최적부분구조(optimal substructure): 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제으이 답을 모아서 큰 문제를 해결
    2. 중복되는부분문제(overlapping subproblem): 동일한 작은 문제를 반복적으로 해결 

* 다이나믹 프로그래밍 문제에 접근하는 방법    
가장먼저 그리디,구현,완전탐색 등의 아이디어로 문제를 해결할 수 있는지 검토    
다른알고리즘으로 풀이 방법이 떠오르지 않는다면 다이나믹 프로그래밍을 검토    
일단 재귀함수로 비효율적인 완전탐색 프로그램을 작성한 뒤에(탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용    

### 🌟🌟**피보나치 수열**
피보나치 수열은 다음과 같은 형태의 수열이며, 다이나믹 프로그래밍을 효과적으로 계산    
1,1,2,3,5,8,13,21,34,55,89    

점화식이란 인접한 항들 사이의 관계식을 의미    
피보나치 수열을 점화식으로 표현하면 다음과 같다    
            <img src=dynamic_pic/dynamic1.jpeg width=55%></img>     

피보나치수열이 계산되는 과정     
            <img src=dynamic_pic/피보나치수열.jpeg width=55%></img>    
```py
#피보나치수열: 단순재귀소스코드
def fibo(x):
    if x ==1 or x==2:
        return 1
    return fibo(x-1)+fibo(x-2)
print(fibo(4)) #3
```    

단순 재귀함수로 피보나치 수열을 해결하면 지수 시간복잡도를 가진다(중복되는 부분문제)   
다음과 같이 f(2)가 여러번 호출되는 것을 확인할 수 있다     
            <img src=dynamic_pic/피보나치시간복잡도.jpeg width=55%></img>       
피보나치 수열의 시간복잡도는 다음과 같다
* 세타 표기법: 𝜭(1.618...ᴺ)    
* 빅오표기법: O(2ᴺ)     

피보나치 수열의 효율적인 해법->다이나믹프로그래밍 조건만족여부확인    
1.최적부분구조   
2.중복되는 부분문제   


### 🌟🌟**메모이제이션(Memoization)**  
다이나믹 프로그래밍을 구현하는 방법 중 하나   
한 번 계산한 결과를 메모리 공간에 메모    
메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간복잡도는 O(N)

    * 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴  
    * 값을 기록해 놓는다는 점에서 캐싱(Chaching)이라고 한다

### 🌟🌟**탑다운 VS 보텀업**     
탑다운(메모이제이션)방식은 하향식이라고도 하며        
 보텀업 방식은 상향식이라고 한다=반복문   

다이나믹 프로그래밍의 전형적인 형태는 보텀업방식 ->결과저장용 리스트는 DP테이블이라고 부른다         
메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념    

-피보나치수열: 탑다운 다이나믹 프로그래밍    
```py
#한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d=[0]*100

#피보나치 함수를 재귀함수로 구현
def fibo(x):
    #종료조건(1혹은2일때 1을 반환)
    if x==1 or x==2:
        return 1
    #이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] !=0:
        return d[x]
    #아직 계산하지 않은 문제라먄 점화식에 띠라서 피보나치 결과 반환
    d[x]=fibo(x-1)+fibo(x-2)
    return d[x]
print(fibo(99)) #218922995834555169026
```

-피보나치수열: 보텀업 다이나믹 프로그래밍 
```py
#앞서 계산된 결과를 저장하기 위한 dp테이블초기화
d=[0]*100
#첫번째 피보나치 수와 두번째 피보나치 수는 1
d[1]=1
d[2]=1
n=99

#피보나치 함수반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3, n+1):
    d[i]=d[i-1]+d[i-2]
```

* 피보나치수열:메모이제이션 동작분석    
    이미 계산된 결과를 메모리에 저장하면 다음과 같이 색칠된 노드만 처리할 것을 기대   
            <img src=dynamic_pic/메모이제이션.jpeg width=55%></img> 

    실제로 호출되는 함수에 대해서만 확인해 보면 다음과 같이 방문    
            <img src=dynamic_pic/메모이제이션2.jpeg width=55%></img>    


### 🌟🌟**다이나믹프로그래밍 VS 분할정복**  
모두 최적 부분 구조를 가질 때 사용    
큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황    

둘의 차이점은 부분 문제의 중복    
다이나믹프로그램-> 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복    
분할정복문제-> 동일한 부분 문제가 반복적으로 계산되지 않는다    



