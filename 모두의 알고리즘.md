## 알고리즘   
-주어진 "입력" 정보를 원하는 "출력" 정보로 만드는 일련의 과정   
-한가지 문제를 푸는 여려가지 방법, 즉 여러가지 알고리즘 중에 상황에 맞는 적당한 알고리즘을 골라 쓰려면 어떤 알고리즘이 어떤 특징을 지니고 있으며 얼마나 계산이 빠르고 편하지를 알아야한다

+ 어떤 문제를 풀기위한 절차나 방법
+ 주어진 "입력"을 "출력"으로 만드는 과정
+ 각 단계는 구체적이고 명료    

## 대문자 0표기법:시간복잡도표현
문제를 풀기위해 해야하는 계산이 얼마나 복잡한지 나타낸 정도를 "계산복잡도"   

필요한 계산횟수가 입력 크기에 "정비례"할때는 0(N)이라고 표현   

입력크기 N과 필요한 계산의 횟수가 무관하다면, 즉 입력 크기가 커져도 계산 시간이 더 늘어나지 않는다면 모두 0(1)로 표기

N의 변화에 따라 가장 크게 변하는 항의 계수를 생략생략하여 표현

* 0(1): N과 무관하게 일정한 시간이 걸림
* 0(N): N과 비례하여 계산 시간이 증가
* 0(N²): N의 제곱에 비례하여 게산 시간이 증가   
* 0(2ⁿ): 2의 N제곱에 비례하여 계산 시간이 증가  

시간복잡도: 수행시간, 어떤 알고리즘을 수행하는데 얼마나 오랜 시간이 걸리는 분석    
공간복잡도: 필요한 메모리, 어떤 알고리즘을 수행하는데 얼마나 많은 공간(메모리,기억장소)기 필요한지 분석

## 알고리즘기초

### 🚀절대값 구하기 알고리즘
***
**절대값구하기(부호판단)**  
입력:실수a   
출력:a의 절대값   
```py
import math

def abs_sign(a):
    if a>=0:
        return a
    else:
        return -a

print(abs_sign(5)) #5
print(abs_sign(-3)) #3
```

**절대값구하기(제곱-제곱근)**     
입력:실수a   
출력:a의 절대값   
값이 5와 3이 아니라 5.0과 3.0이 출력된 이유는 파이썬의 제곱근 함수인 math.sqrt(b)가 소수점이 붙은 값을 돌려줌   
```py
import math

def abs_square(a):
    b=a*a
    return math.sqrt(b) #수학모듈의제곱근함수

print(abs_square(5)) #5.0
print(ans_square(3)) #3.0
```

### 🚀1부터 N까지 합구하기
***
**무한덧셈**   
덧셈n번
```py
def sum_n(n): 
    s=0 #합을 게산할 변수
    for i in range(0,n+1):
        s +=i
    return s

print(sum_n(10)) #55
print(sum_n(100)) #5050
```
**가우스방식**   
곱셈,덧셈,나눗셈 각 한번(총세번)
```py
def sum_n(n):
    return n*(n+1)//2
print(sum_n(10))
print(sum_n(100))
```
**1부터 n까지 제곱의 합**
```py
def sum_sq(n):
    s=0
    for i in range(1, n+1):
        s +=i*i
    return s
print(sum_sq(10)) #385


def sum_sq(n):
    return n*(n+1)*(2*n+1)//6
print(sum_sq(10)) #385
```

### 🚀최대값 찾기
***
* 리스트   
자료가 n개 들어있는 리스트 a가 있다면 첫번째 값은 a[0], 마지막값은 a[n-1]또는 a[-1]로 표현
    >len(a)   
    append(x)   
    insert(i,x)   
    pop(i)   
    clear()   
    x in a   


**최대값구하기**   
입력: 숫자 n개 들어가있는리스트      
출력: 숫자 n개 중 최대값  
시간복잡도:0(N) 
```py
def find_max(a):
    n=len(a) #입력크기:n
    max=a[0] #리스트의 첫번째 값을 최대값으로 기억

    for i in range(1, n): #1부터 n-1까지 반복
        if a[i]>max: #이번값이 현재까지 기억된 최대값보다 크면
            max=a[i] #최대값을 변경
    return max

list=[17,22,55,23,6,1]
print(find_max(list))
```
**최대값위치구하기**  
입력: 숫자가 n개 들어가있는리스트   
출력: 숫자 n개 중에 최대값이 들어있는 위치   
```py
def find_idx(a):
    n=len(a)
    idx=0
    for i in range(1, n):
        if a[i]>a[idx]:
            idx=i
    return idx
list=[17,22,55,23,6,1]
print(find_idx(list))
```

### 🚀동명이인 찾기
***
* 집합    
이문제의 출력은 같은 이름이 들어 있는 집합    
리스트와 같이 정보를 여러개 넣어 보관(자료의 순서가 의미가 없다는 점이 리스트와 다름)
    >len(s)    
    add(x)   
    discard(x) 집합에 자료 x가 들어있다면 삭제(없으면 변화없음)   
    clear()   
    x in s  


**두번이상나온이름찾기**   
입력: 이름이 n개 들어있는 리스트   
출력:이름 n개 중 반복되는 이름의 집합    
계산복잡도: 0(n²)    
```py
def find_same_name(a):
    n=len(a) #리스트의 자료개수를 n에 저장
    result=set() #결과를 저장할 빈 집합
    for i in range(0, n-1): #0~n-2 #자기 자신과 비교할 필요가 없기때문에 하나뺀다
        for j in range(i+1,n): #n+1~n-1 #첫번째자기자신과 마지막과는 비교할 필요가 없다
            if a[i]==a[j]: #이름이 같으면
                result.add(a[i]) 
    return result
name=["tom","jerry","mike","tom"]
print(find_same_name(name)) #{'tom'}
```

## 재귀호출
-재귀호출은 어떤 함수 안에서 자기 자신을 부르는 것   
-반복을 멈추려면 Ctrl+C   
-재귀호출함수가 계산결과를 돌려줄 때는 return명령을 사용해서 종료조건의 결과값부터 돌려준다   
-종료조건의 결과값은 곧 마지막으로 호출된 결과값이므로 러시아인형의 마지막 상품으로 들어있는 사탕과 비슷   
-반복문을 이용한 알고리즘이나 재귀호출을 이용한 알고리즘의 계산 복잡도는 모두 0(N)   

### 🚀팩토리얼 구하기
***
1부터 n까지의 곱, "계승"이라고도 함   
단, 0!이나 1!은 1이라고 약속   

**팩토리얼구하기**   
입력:n   
출력:1부터 n까지 연속한 숫자를 곱한값
```py
def fact(n):
    f=1 #곱을계산할변수, 초기값은1
    for i in range(1,n+1):
        f *=i
    return f
print(fact(5))
```
n!=n x (n-1)! ->팩토리얼을 구하려고 다시 팩토리얼을 구함(재귀적 정의)
```py
def fact(n):
    if n <=1: #종료조건 
        return 1
    return n*fact(n-1)
print(fact(5))
```
1부터 n까지의합구하기
```py
def fact_practice(n):
   if n ==0:
      return 0
   return n+fact_practice(n-1)
print(fact_practice(10)) #55
```

### 🚀최대공약수 구하기
***
최대공약수(GCD)는 두개 이상의 정수의 공통 약수 중에서 가장 큰 값을 의미   

**최대공약수구하기**   
입력:a,b   
출력:a와b의 최대공약수
```py
def gcd(a,b):
    i=min(a,b) #두수중에서 최소값을 구하는 파이썬함수
    while True:
        if a%i==0 and b%i==0:
            return i
        i -=1
print(gcd(60,24))
```

**유클리드**    
* gcd(a,b)=gcd(b,a%b)   
* gcd(n,0)=n   
a와 b의 최대공약수를 구하기 위해서 (a,b)보다 좀 더 작은 숫자인 (b,a%b)의 최대공약수를 구하는 과정을 이용하는 전형적인 재귀호출문제   
(좀 더 작은 값으로 자기 자신을 호출)    
종료조건: 어떤 수와 0의 최대공약수는 자기자신   
입력:a,b   
출력:a와 b의 최대공약수    
```py
def gcd(a,b):
    if b ==0:
        return a #종료조건
    return gcd(b, a%b) #좀 더 작은 값으로 자기 자신을 호출
print(gcd(24,60))
```

### 🚀하노이의 탑 옮기기
입력:옮기려는 원반의 개수 n(출발점기둥:from_pos, 도착점기둥:to_pos,보조기둥:aux_pos)    
출력:원반을 옮기는 순서   
계산복잡도: 0(2ⁿ)->N층짜리 하노이의 탑을 옮기려면 원반을 모두 2ⁿ-1번 옮겨야 한다
```py
def hanoi(n, from_pos, to_pos, aux_pos):
    #원반 한개를 옮기는 문제
    if n ==1:
        print(from_pos,"->", to_pos)
        return

    #원반 n-1개를 aux_pos로 이동
    hanoi(n-1,from_pos,aux_pos,to_pos)
    print(from_pos,"->", to_pos)

    #aux_pos에 있는 원반 n-1개를 to_pos로 이동 
    hanoi(n-1,aux_pos,to_pos,from_pos)


print("n=1") 
hanoi(1,1,3,2)

print("n=2")
hanoi(2,1,3,2)

# n=1
# 1 -> 3
# n=2
# 1 -> 2
# 1 -> 3
# 2 -> 3
```