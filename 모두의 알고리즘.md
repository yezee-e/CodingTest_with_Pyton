## 알고리즘   
-주어진 "입력" 정보를 원하는 "출력" 정보로 만드는 일련의 과정   
-한가지 문제를 푸는 여려가지 방법, 즉 여러가지 알고리즘 중에 상황에 맞는 적당한 알고리즘을 골라 쓰려면 어떤 알고리즘이 어떤 특징을 지니고 있으며 얼마나 계산이 빠르고 편하지를 알아야한다

+ 어떤 문제를 풀기위한 절차나 방법
+ 주어진 "입력"을 "출력"으로 만드는 과정
+ 각 단계는 구체적이고 명료    

## 대문자 0표기법:시간복잡도표현
문제를 풀기위해 해야하는 계산이 얼마나 복잡한지 나타낸 정도를 "계산복잡도"   
필요한 계산횟수가 입력 크기에 "정비례"할때는 0(N)이라고 표현   
입력크기 N과 필요한 계산의 횟수가 무관하다면, 즉 입력 크기가 커져도 계산 시간이 더 늘어나지 않는다면 모두 0(1)로 표기    
N의 변화에 따라 가장 크게 변하는 항의 계수를 생략생략하여 표현
* 0(N): 필요한 계산 횟수가 입력 크기 N과 비례
* 0(1): 필요한 계산 횟수가 입력 크기 M과 무관   

시간복잡도: 수행시간, 어떤 알고리즘을 수행하는데 얼마나 오랜 시간이 걸리는 분석    
공간복잡도: 필요한 메모리, 어떤 알고리즘을 수행하는데 얼마나 많은 공간(메모리,기억장소)기 필요한지 분석

## 알고리즘기초

### 🚀절대값 구하기 알고리즘
***
**절대값구하기(부호판단)**  
입력:실수a   
출력:a의 절대값   
```py
import math

def abs_sign(a):
    if a>=0:
        return a
    else:
        return -a

print(abs_sign(5)) #5
print(abs_sign(-3)) #3
```

**절대값구하기(제곱-제곱근)**     
입력:실수a   
출력:a의 절대값   
값이 5와 3이 아니라 5.0과 3.0이 출력된 이유는 파이썬의 제곱근 함수인 math.sqrt(b)가 소수점이 붙은 값을 돌려줌   
```py
import math

def abs_square(a):
    b=a*a
    return math.sqrt(b) #수학모듈의제곱근함수

print(abs_square(5)) #5.0
print(ans_square(3)) #3.0
```

### 🚀1부터 N까지 합구하기
***
**무한덧셈**   
덧셈n번
```py
def sum_n(n):
    #합을 게산할 변수 
    s=0 
    for i in range(0,n+1):
        s +=i
    return s

print(sum_n(10)) #55
print(sum_n(100)) #5050
```
**가우스방식**   
곱셈,덧셈,나눗셈 각 한번(총세번)
```py
def sum_n(n):
    return n*(n+1)//2
print(sum_n(10))
print(sum_n(100))
```
**1부터 n까지 제곱의 합**
```py
def sum_sq(n):
    s=0
    for i in range(1, n+1):
        s +=i*i
    return s
print(sum_sq(10)) #385


def sum_sq(n):
    return n*(n+1)*(2*n+1)//6
print(sum_sq(10)) #385
```

### 🚀최대값 찾기
***
* 리스트   
자료가 n개 들어있는 리스트 a가 있다면 첫번째 값은 a[0], 마지막값은 a[n-1]또는 a[-1]로 표현
    >len(a)   
    append(x)   
    insert(i,x)   
    pop(i)   
    clear()   
    x in a   

**최대값구하기**   
입력: 숫자 n개 들어가있는리스트      
출력: 숫자 n개 중 최대값  
시간복잡도:0(N) 
```py
def find_max(a):
    n=len(a) #입력크기:n
    max=a[0] #리스트의 첫번째 값을 최대값으로 기억

    for i in range(1, n): #1부터 n-1까지 반복
        if a[i]>max: #이번값이 현재까지 기억된 최대값보다 크면
            max=a[i] #최대값을 변경
    return max

list=[17,22,55,23,6,1]
print(find_max(list))
```
**최대값위치구하기**  
입력: 숫자가 n개 들어가있는리스트   
출력: 숫자 n개 중에 최대값이 들어있는 위치   
```py
def find_idx(a):
    n=len(a)
    idx=0
    for i in range(1, n):
        if a[i]>a[idx]:
            idx=i
    return idx
list=[17,22,55,23,6,1]
print(find_idx(list))
```

### 🚀동명이인 찾기
***
* 집합    
이문제의 출력은 같은 이름이 들어 있는 집합    
리스트와 같이 정보를 여러개 넣어 보관(자료의 순서가 의미가 없다는 점이 리스트와 다름)
    >len(s)    
    add(x)   
    discard(x) 집합에 자료 x가 들어있다면 삭제(없으면 변화없음)   
    clear()   
    x in s 

**두번이상나온이름찾기**   
입력: 이름이 n개 들어있는 리스트   
출력:이름 n개 중 반복되는 이름의 집합    
계산복잡도: 0(n^2)    
```py
def find_same_name(a):
    n=len(a) #리스트의 자료개수를 n에 저장
    result=set() #결과를 저장할 빈 집합
    for i in range(0, n-1): #0~n-2 #자기 자신과 비교할 필요가 없기때문에 하나뺀다
        for j in range(i+1,n): #n+1~n-1 #첫번째자기자신과 마지막과는 비교할 필요가 없다
            if a[i]==a[j]: #이름이 같으면
                result.add(a[i]) 
    return result
name=["tom","jerry","mike","tom"]
print(find_same_name(name)) #{'tom'}
```

## 재귀호출
-재귀호출은 어떤 함수 안에서 자기 자신을 부르는 것   
-반복을 멈추려면 Ctrl+C   
-재귀호출함수가 계산결과를 돌려줄 때는 return명령을 사용해서 종료조건의 결과값부터 돌려준다   
-종료조건의 결과값은 곧 마지막으로 호출된 결과값이므로 러시아인형의 마지막 상품으로 들어있는 사탕과 비슷   
-반복문을 이용한 알고리즘이나 재귀호출을 이용한 알고리즘의 계산 복잡도는 모두 0(N)   

### 🚀팩토리얼 구하기
***
1부터 n까지의 곱, "계승"이라고도 함   
단, 0!이나 1!은 1이라고 약속
**팩토리얼구하기**
입력:n
출력:1부터 n까지 연속한 숫자를 곱한값
```py
def fact(n):
    f=1 #곱을계산할변수, 초기값은1
    for i in range(1,n+1):
        f *=i
    return f
print(fact(5))
```
n!=n x (n-1)! ->팩토리얼을 구하려고 다시 팩토리얼을 구함(재귀적 정의)
```py
def fact(n):
    if n <=1: #종료조건 
        return 1
    return n*fact(n-1)
print(fact(5))
```

